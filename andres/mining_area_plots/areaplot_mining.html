<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
        <title>Mining_final</title>
        <link rel="shortcut icon" href="#" />
		<script type="text/javascript" src="../d3.js"></script>
		<style type="text/css">

			/* Lots of new CSS rules! */

			/* HTML page styles */

			* {
				margin: 0;
				padding: 0;
			}

			body {
				font-family: Helvetica, Arial, sans-serif;
				background-color: #eee;
			}

			#container {
				width: 1000px;
				margin: 25px auto 25px auto;
				padding: 50px 50px 50px 50px;
				background-color: white;
				box-shadow: 0 0 20px #ccc;
			}

			h1 {
				margin-bottom: 25px;
				font-size: 24px;
				font-weight: bold;
			}

			h2 {
				margin-top: 30px;
				margin-left: 20px;
				font-size: 14px;
			}

			p {
				margin-bottom: 25px;
				font-size: 14px;
				line-height: 18px;
			}

			button {
				padding: 15px;
			}

			#footer p {
				margin-top: 50px;
				margin-bottom: 0;
				font-size: 10px;
				line-height: 14px;
				color: gray;
			}
			
			#footer p a {
				color: gray;
			}

			/* Chart styles */

			svg {
				display: block;
				margin-bottom: 10px;
				background-color: gray;
			}

			.area {
				stroke: black;
				cursor: pointer;
			}

			.area:hover {
				fill: rgb(175, 240, 91);
			}
			
			#backButton {
				cursor: pointer;
			}
			
			#backButton rect {
				fill: rgb(175, 240, 91);
			}
			
			#backButton text {
				font-family: Helvetica, sans-serif;
				font-weight: bold;
				font-size: 14px;
				fill: black;
			}
			
			#backButton:hover rect {
				fill: rgb(26, 199, 194);
			}
			
			#backButton:hover text {
				fill: white;
			}
			
			.unclickable {
				pointer-events: none;
			}

		</style>
	</head>
	<body>

		<!-- New HTML structure and content! -->
		<div id="container">

			<h1>Amazonic Rain  Forest Mining Activity "Region of Peru"</h1>
			<h2>Introduction</h2>
			<p>
                In the last year gold mining has destroyed almost 100000 hectares of rainforest in the Peruvian amazon region, almost 10 times the size of Paris, this activity is not just destroying the rainforest of the region, but also contaminating the soil with the toxic compounds used to extract the gold from the soil, mainly mercury. There are two different types of mining types:  “Heavy Machinery“ that uses big trucks and latest to extract the gold from the soil, “Suction Pumps” composed of washers and more traditional methods to extract the gold.
                We will analyze the data and presented as a timeline interactive graphic to show the effects that this activity is causing to the peruvian rainforest.
                .<p>

			<div id="chartContainer">
				<h2>Increase of the area of mining in the amazonic rain forest by Type : Heavy Machinery and Suction Pumps.<br/>
					During the period: January 1985&ndash;Januar 2017</h2>
            </div>
            <h2>1985</h2>
            The first record of gold mining at this region is in 1985, as you can see in the map it started with 73.9 ha and distributed between the sectors : Huepetuhe, Delta and Small Mines.
            At this time the sector with the highest percentage of mining activity was : <b>Huepetue/Heavy Machinery with 35.73 ha.</b>
            The relation between the two different mining methods was 55% for Heavy Machinery and 45% for Suction Pumps.
            
            <h2>1993</h2>
            In 1993 there was an increase of 1036% for the mining activity of the region. A total of 839.5 ha distributed between the sectors : Huepetuhe, Delta and small mines.
            As you can observe the sector with the highest percentage remain as <b>Huepetue with 644.13 ha of Heavy Machinery mining.</b>
            The relation between the two different mining methods was 83% for Heavy machinery and 17% for Suction pumps, we can see that the Heavy Machinery was the dominating method to extract the gold with an increase of 1618% and a total of 695.6 ha.

            <h2>2001</h2>
            In 2001 there was an increase of 10% between 1985. A total of 919.6 ha was used for the gold mining activity, at this point another sector was added to the region, the sector of : Pampa.
            The sector with the highest percentage of gold mining activity is : <b>Small Mines with 620.63 ha of Suction Pumps mining.	</b>
            The relation between the two different mining methods was 23% for Heavy Machinery and 77% for Suction Pumps, we can see an exceptional change compared to the previous year, with an abrupt
            increase of the mines that use Suction Pumps, with a total of 708.5 ha and an increase of 392%. However the Heavy machinery  decreased -70% with a total of 211.1 ha.
            
            <h2>2009</h2>
            In 2009 the increase of mining activity compared to 1985 was alarming, an increase of 151% over the area used for mining, a total of 2304.6 ha of the peruvian amazon rainforest was destroyed and contaminated because of the gold mining. 
            The sectors where the mining was done : Huepetuhe, Delta, Pampa and small mines. The sector with the highest percentage was : <b>Pampa with 962.47 ha of suction pumps mining.</b>
            The relation between the two different mining methods was 20%-80% for heavy machinery and suction pumps. We can see that the suction pump remain as the main method for mining the gold. We have an increase of 161% for suction pumps with a total of 1846.1 ha and an increase of 117% for heavy machinery and a total of 458.4 ha
            
            <h2>2017</h2>
            In 2017 things became critical, the gold mining activity had an increase of 328% compared to 2009, with an area of 9859.8 ha, almost  the size of Paris of peruvian amazon rainforest was destroyed and contaminated.  
            At this moment the activity was distributed over the sectors: Huepetuhe, Delta, Pampa and small mines. The sector with the highest percentage of mining is <b> Small Mines with 4486.9 ha of Suction Pumps. </b>
            The relation between the two different mining methods was 34%-66% for heavy machinery and suction pumps. We can see that the suction pump is the main method for mining gold, with an increase of 252% and a total of 6497.5 ha compared to an increase of 633% for heavy machinery and a total of 3362.3 ha.


			<div id="footer">
				<p><strong>Source:</strong> Data was provided by PRO-AGUA project in collaboration with Standford</p>
			</div>

		</div>
		
		<script type="text/javascript">

			//Width and height
			var w = 1000;
			var h = 300;
			var padding = 20;
			
			//Tracks view state.  Possible values:
			// 0 = default (areas types)
			// 1 = areas (of one type)
			// 2 = areas (singular)
			var viewState = 0;
			
			//Tracks most recently viewed/clicked 'type'.  Possible values:
			//"Heavy_Machinery", "Single_Pumps" or undefined
			var viewType;
			
			var dataset, thisTypeDataset, xScale, yScale, xAxis, yAxis, area;  //Empty, for now

			//For converting strings to Dates
			var parseTime = d3.timeParse("%Y-%m");

			//For converting Dates to strings
			var formatTime = d3.timeFormat("%Y");
			
			//Define key function, to be used when binding data
			var key = function(d) {
				return d.key;
			};

			//Set up stack methods
			var areaStack = d3.stack();
			var typeStack = d3.stack();

			//Load in data
			d3.request("Book3.csv")
				.mimeType("text/csv")
				.get(function(response) {



					//
					// DATA PARSING
					//

					//Parse each row of the CSV into an array of string values
					var rows = d3.csvParseRows(response.responseText);
					console.log(rows);
					
					//Make dataset an empty array, so we can start adding values
					dataset = [];
					
					//Loop once for each row of the CSV, starting at row 3,
					//since rows 0-2 contain only area info, not area values.
					for (var i = 2; i < rows.length; i++) {
						
						//Create a new object
						dataset[i - 2] = {
							date: parseTime(rows[i][0])  //Make a new Date object for each year + month
						};
						
						//Loop once for each area in this row (i.e., for this date)
						for (var j = 1; j < rows[i].length; j++) {
						
							var sector			    = rows[0][j];  
							var mining_type			= rows[1][j];
							var mining_type_sector	= rows[1][j] + " " + rows[0][j];  //
							var area_val   			= rows[i][j];  
							//If area value exists…
							if (area_val) {
								area_val = parseInt(area_val);  //Convert from string to int
							} else {  //Otherwise…
								area_val = 0;  //Set to zero
							}

							//Append a new object with data for this row
							dataset[i - 2][mining_type_sector] = {
								
								"mining_type": mining_type,
								"sector": sector,
								"area_val": area_val
								// "coords": coords
								};
							
						}

					}

					//Log out the final state of dataset
					console.log(dataset);

									
					//
					//	TYPE DATA SERIES
					//
					
					//The goal here is to make a totally separate data set that
					//includes just monthly totals for each `type` (Heavy_Machinery, Suction_Pumps).
					
					//Make typeDataset an empty array, so we can start adding values
					typeDataset = [];
					
					//Loop once for each row of the CSV, starting at row 3,
					//since rows 0-2 contain only area info, not area values.
					for (var i = 2; i < rows.length; i++) {
						
						//Create a new object
						typeDataset[i - 2] = {
							date: parseTime(rows[i][0]),  //Make a new Date object for each year 
							"Heavy_Machinery": 0,
							"Suction_Pumps": 0
						};
						
						//Loop once for each area in this row (i.e., for this date)
						for (var j = 1; j < rows[i].length; j++) {
						
							var mining_type 	= rows[1][j];  //'Type' from 2 row in CSV
							var area_val	    = rows[i][j];  //area value for this area 
							
							//If area value exists…
							if (area_val) {
								area_val = parseInt(area_val);  //Convert from string to int
							} else {  //Otherwise…
								area_val = 0;  //Set to zero
							}

							//Add area value to existing sum
							typeDataset[i - 2][mining_type] += area_val;
							
						}

					}

					//Log out the final state of dataset
					console.log(typeDataset);



					//
					// STACKING
					//

					//Tell stack function where to find the keys
					var types = [ "Heavy_Machinery", "Suction_Pumps" ];
					typeStack.keys(types);

					//Stack the data and log it out
					var typeSeries = typeStack(typeDataset);
					console.log(typeSeries);



					//
					// MAKE THE CHART
					//
				
					//Create scale functions
					xScale = d3.scaleTime()
							   .domain([
									d3.min(dataset, function(d) { return d.date; }),
									d3.max(dataset, function(d) { return d.date; })
								])
							   .range([padding, w - padding * 2]);
				
					yScale = d3.scaleLinear()
								.domain([
									0,
									d3.max(typeDataset, function(d) {
										var sum = 0;

										//Loops once for each row, to calculate
										//the total (sum) of sales of all areas
										for (var i = 0; i < types.length; i++) {
											sum += d[types[i]];
										};
			
										return sum;
									})
								])
								.range([h - padding, padding / 2])
								.nice();
				
					//Define axes
					xAxis = d3.axisBottom()
							   .scale(xScale)
							   .ticks(10)
							   .tickFormat(formatTime);
				
					//Define Y axis
					yAxis = d3.axisRight()
							   .scale(yScale)
							   .ticks(5);
				
					//Define area generator
					area = d3.area()
								.x(function(d) { return xScale(d.data.date); })
								.y0(function(d) { return yScale(d[0]); })
								.y1(function(d) { return yScale(d[1]); });
				
					//Create SVG element
					var svg = d3.select("#chartContainer")
								.append("svg")
								.attr("width", w)
								.attr("height", h);
				
					
					svg.append("g")
						.attr("id", "Areas_ha");

					//Create areas for TYPES
					svg.append("g")
						.attr("id", "types")
						.selectAll("path")
						.data(typeSeries, key)
						.enter()
						.append("path")
						.attr("class", "area")
						.attr("opacity", 1)
						.attr("d", area)
						.attr("fill", function(d) {

							//Which type is this?
							var thisType = d.key;
							
							//New color var
							var color;

							switch (thisType) {
								case "Heavy_Machinery":
									color = "rgb(95,48,44)";
									break;
								
								case "Suction_Pumps":
									color = "rgb(69,51,88)";
									break;
							}
							
							return color;
						})
						.on("click", function(d) {
							
							//Update view state
							viewState++;
							
							//
							// TYPES
							//
							
							//Which type was clicked?
							var thisType = d.key;
							
							//Update this for later reference
							viewType = thisType;
							
							//Generate a new data set with all-zero values, 
							//except for this type's data
							thisTypeDataset = [];
							
							for (var i = 0; i < typeDataset.length; i++) {
								thisTypeDataset[i] = {
									date: 		typeDataset[i].date,
									Heavy_Machinery:		0,
									Suction_Pumps:		0,
									[thisType]:	typeDataset[i][thisType]  //Overwrites the appropriate zero value above
								}
							}
							
							console.log(thisTypeDataset);
							
							//Stack the data (even though there's now just one "layer") and log it out
							var thisTypeSeries = typeStack(thisTypeDataset);
							console.log(thisTypeSeries);

							//Bind the new data set to paths, overwriting old bound data.
							var paths = d3.selectAll("#types path")
								.data(thisTypeSeries, key)
								.classed("unclickable", true);

							//Transition areas into new positions (i.e., thisType's area
							//will go to a zero baseline; all others will flatten out).
							//
							//Store this transition in a new variable for later reference.
							var areaTransitions = paths.transition()
								.duration(1000)
								.attr("d", area);
								
							//Update scale
							yScale.domain([
									0,
									d3.max(thisTypeDataset, function(d) {
										var sum = 0;
			
										//Calculate the total (sum) of sales of this type,
										//ignoring the others (for now)
										sum += d[thisType];
										
										return sum;
									})
								]);

							//Append this transition to the one already in progress
							//(from above).  Transition areas to newly updated scale.
							areaTransitions.transition()
								.delay(200)
								.on("start", function() {

									//Transition axis to new scale concurrently
									d3.select("g.axis.y")
										.transition()
										.duration(1000)
										.call(yAxis);
											
								})
								.duration(1000)
								.attr("d", area)
								.transition()
								.on("start", function() {
									//Make areas visible instantly, so 
									//they are revealed when this fades out
									d3.selectAll("g#Areas_ha path")
										.attr("opacity", 1);
								})
								.duration(1000)
								.attr("opacity", 0)
								.on("end", function(d, i) {
									//Reveal back button
									if (i == 0) {
										toggleBackButton();
									}
								});

							//
							// areas
							//

							//Get all possible keys (make + model), but toss out 'date'
							var keysAll = Object.keys(dataset[0]).slice(1);
							console.log(keysAll);
							
							//Loop once for each key, and save out just the ones of thisType (e.g. BEVs)
							var keysOfThisType = [];
							for (var i = 0; i < keysAll.length; i++) {
								if (dataset[0][keysAll[i]].mining_type == thisType) {
									keysOfThisType.push(keysAll[i]);
								}
							}
							console.log(keysOfThisType);

							//Give the new keys to the stack function
							areaStack.keys(keysOfThisType)
								.value(function value(d, key) {
									return d[key].area_val;
								});

							//Stack the data and log it out
							var areaSeries = areaStack(dataset);
							console.log(areaSeries);

							//Create areas for individual areas
							svg.select("g#Areas_ha")
								.selectAll("path")
								.data(areaSeries, key)
								.enter()
								.append("path")
								.attr("class", "area")
								.attr("opacity", 0)
								.attr("d", area)
								.attr("fill", function(d, i) {

									//Which area is this?
									var thisKey = d.key;
									
									//What 'type' is this area?
									var thisType = d[0].data[thisKey].mining_type;
									console.log(thisType);

									//Used to find a cool color below
									var spread = 0.35;
									var startingPoint;

									//Choose where in the color spectrum we start, based on type
									switch (thisType) {
										case "Heavy_Machinery":
											startingPoint = 0;
											break;
										
										case "Suction_Pumps":
											startingPoint = 0.35;
											break;
									}

									//How many areas?
									var numAreas_ha = keysOfThisType.length;
									
									//Get a value between 0.0 and 1.0
									var normalized = startingPoint + ((i / numAreas_ha) * spread);

									//Get that color on the spectrum
									return d3.interpolateCool(normalized);
								})
								.on("click", function(d) {

									//Update view state
									viewState++;
									
									//Hide the back button during this view transition
									toggleBackButton();
									
									//Which area was clicked?
									var thisType = d.key;

									//Fade out all other areas
									d3.selectAll("g#Areas_ha path")
										.classed("unclickable", true)  //Prevent future clicks
										.filter(function(d) {  //Filter out 'this' one
											if (d.key !== thisType) {
												return true;
											}
										})
										.transition()
										.duration(1000)
										.attr("opacity", 0);
									
									//Define area generator that will be used just this one time
									var singleArea_ha_Area = d3.area()
										.x(function(d) { return xScale(d.data.date); })
										.y0(function(d) { return yScale(0); })  //Note zero baseline
										.y1(function(d) { return yScale(d.data[thisType].area_val); });
										//Note y1 uses the raw 'sales' value for 'this' area,
										//not the stacked data values (e.g., d[0] or d[1]).

									//Use this new area generator to transition the area downward,
									//to have a flat (zero) baseline.
									var thisAreaTransition = d3.select(this)
										.transition()
										.delay(1000)
										.duration(1000)
										.attr("d", singleArea_ha_Area);

									//Update y scale domain, based on the sales for this area only
									yScale.domain([
											0,
											d3.max(dataset, function(d) {
												return d[thisType].area_val;
											})
										]);
									
									//Transitions the clicked area and y axis into place, to fit the new domain
									thisAreaTransition
										.transition()
										.duration(1000)
										.attr("d", singleArea_ha_Area)
										.on("start", function() {

											//Transition axis to new scale concurrently
											d3.select("g.axis.y")
												.transition()
												.duration(1000)
												.call(yAxis);
													
										})
										.on("end", function() {
											//Restore clickability (is that a word?)
											d3.select(this).classed("unclickable", "false");
											
											//Reveal back button
											toggleBackButton();
										});
										
								})
								.append("title")  //Make tooltip
								.text(function(d) {
									return d.key;
								});					

						})
						.append("title")  //Make tooltip
						.text(function(d) {
							return d.key;
						});
				
					//Create axes
					svg.append("g")
						.attr("class", "axis x")
						.attr("transform", "translate(0," + (h - padding) + ")")
						.call(xAxis);
				
					svg.append("g")
						.attr("class", "axis y")
						.attr("transform", "translate(" + (w - padding * 2) + ",0)")
						.call(yAxis);

                    

					//Create back button
					var backButton = svg.append("g")
						.attr("id", "backButton")
						.attr("opacity", 0)				//Initially hidden
						.classed("unclickable", true)	//Initially not clickable
						.attr("transform", "translate(" + xScale.range()[0] + "," + yScale.range()[1] + ")");
					
					backButton.append("rect")
						.attr("x", 0)
						.attr("y", 0)
						.attr("rx", 5)
						.attr("rx", 5)
						.attr("width", 70)
						.attr("height", 30);
					
					backButton.append("text")
						.attr("x", 7)
						.attr("y", 20)
						.html("&larr; Back");
					
					//Define click behavior
					backButton.on("click", function() {
						
						//Hide the back button, as it was just clicked
						toggleBackButton();
						
						if (viewState == 1) {
							//Go back to default view
						
							//Update view state
							viewState--;
							
							//Re-bind type data and fade in types
							var typeAreaTransitions = d3.selectAll("g#types path")
								.data(typeSeries, key)
								.transition()
								.duration(250)
								.attr("opacity", 1)
								.on("end", function() {
									//Remove all Areas_ha once this fades in;
									//they will be recreated later as needed.
									d3.selectAll("g#Areas_ha path").remove();
								});

							//Set y scale back to original domain
							yScale.domain([
									0,
									d3.max(typeDataset, function(d) {
										var sum = 0;

										//Loops once for each row, to calculate
										//the total (sum) of sales of all areas
										for (var i = 0; i < types.length; i++) {
											sum += d[types[i]];
										};

										return sum;
									})
								]);

							//Transition type areas and y scale back into place
							typeAreaTransitions.transition()
								.duration(1000)
								.on("start", function() {
							
									//Transition axis to new scale concurrently
									d3.select("g.axis.y")
										.transition()
										.duration(1000)
										.call(yAxis);
											
								})
								.attr("d", area)
								.on("end", function() {
									d3.select(this).classed("unclickable", false);
								});
							
						} else if (viewState == 2) {
							//Go back to areas view
							
							//Update view state
							viewState--;							

							//Restore the old y scale
							yScale.domain([
									0,
									d3.max(thisTypeDataset, function(d) {
										var sum = 0;
							
										//Calculate the total (sum) of sales of this type
										sum += d[viewType];
										
										return sum;
									})
								]);

							//Transition the y axis and visible area back into place
							d3.selectAll("g#Areas_ha path")
								.transition()
								.on("start", function() {

									//Transition y axis to new scale concurrently
									d3.select("g.axis.y")
										.transition()
										.duration(1000)
										.call(yAxis);
											
								})
								.duration(1000)
								.attr("d", area)  //Effectively changes only the selected area
								.transition()
								.duration(1000)
								.attr("opacity", 1)  //Fade in all areas
								.on("end", function(d, i) {
									
									//Restore clickability
									d3.select(this).classed("unclickable", false);
									
									//Reveal back button
									if (i == 0) {
										toggleBackButton();
									}
									
								});
							
						}

					});

				});
			
			
			
			var toggleBackButton = function() {
				
				//Select the button
				var backButton = d3.select("#backButton");
				
				//Is the button hidden right now?
				var hidden = backButton.classed("unclickable");
				
				//Decide whether to reveal or hide it
				if (hidden) {
					
					//Reveal it
					
					//Set up dynamic button text
					var buttonText = "&larr; Back to ";
					// var buttonTextInfo = "&larr; Current View ";
					//Text varies by mode and type
					if (viewState == 1) {
						buttonText += "types of mining HM - SP";
                        // buttonTextInfo += "all types";
					} else if (viewState == 2) {
						buttonText += "type of mining " + viewType +  " by sectors";
                        // buttonTextInfo += "all " + viewType + " Areas_ha"
					}
					
					//Set text
					backButton.select("text").html(buttonText);
					// backButtonIz.select("text").html(buttonTextInfo);
					
					//Resize button depending on text width
					var rectWidth = Math.round(backButton.select("text").node().getBBox().width + 16);
					backButton.select("rect").attr("width", rectWidth);
                    var rectWidth = Math.round(backButton.select("text").node().getBBox().width + 16);
					backButton.select("rect").attr("width", rectWidth);
					
					//Fade button in
					backButton.classed("unclickable", false)
						.transition()
						.duration(500)
						.attr("opacity", 1);
						
				} else {
					
					//Hide it
					backButton.classed("unclickable", true)
						.transition()
						.duration(200)
						.attr("opacity", 0);
					
				}
				
			};
			
		</script>
	</body>
</html>